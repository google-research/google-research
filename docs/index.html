<!DOCTYPE html>
<html lang="en">
<!-- TODO: add debug flag to pop up alert window when error occurs -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-search' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0'/%3E%3C/svg%3E"
        type="image/svg+xml">
    <title>Search Code By Comment</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">

    <script type="text/javascript">
        /**
         * FlexSearch.js v0.7.31 (Bundle)
         * Author and Copyright: Thomas Wilkerling
         * Licence: Apache-2.0
         * Hosted by Nextapps GmbH
         * https://github.com/nextapps-de/flexsearch
         */
        (function _f(self) {
            'use strict'; try { if (module) self = module } catch (e) { } self._factory = _f; var t; function u(a) { return "undefined" !== typeof a ? a : !0 } function aa(a) { const b = Array(a); for (let c = 0; c < a; c++)b[c] = v(); return b } function v() { return Object.create(null) } function ba(a, b) { return b.length - a.length } function x(a) { return "string" === typeof a } function C(a) { return "object" === typeof a } function D(a) { return "function" === typeof a }; function ca(a, b) { var c = da; if (a && (b && (a = E(a, b)), this.H && (a = E(a, this.H)), this.J && 1 < a.length && (a = E(a, this.J)), c || "" === c)) { a = a.split(c); if (this.filter) { b = this.filter; c = a.length; const d = []; for (let e = 0, f = 0; e < c; e++) { const g = a[e]; g && !b[g] && (d[f++] = g) } a = d } return a } return a } const da = /[\s\xA0\u2000-\u200B\u2028\u2029\u3000\ufeff!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]/
 /* /[\p{Z}\p{S}\p{P}\p{C}]+/u */, ea = /[\u0300-\u036f]/g;
            function fa(a, b) { const c = Object.keys(a), d = c.length, e = []; let f = "", g = 0; for (let h = 0, k, m; h < d; h++)k = c[h], (m = a[k]) ? (e[g++] = F(b ? "(?!\\b)" + k + "(\\b|_)" : k), e[g++] = m) : f += (f ? "|" : "") + k; f && (e[g++] = F(b ? "(?!\\b)(" + f + ")(\\b|_)" : "(" + f + ")"), e[g] = ""); return e } function E(a, b) { for (let c = 0, d = b.length; c < d && (a = a.replace(b[c], b[c + 1]), a); c += 2); return a } function F(a) { return new RegExp(a, "g") } function ha(a) { let b = "", c = ""; for (let d = 0, e = a.length, f; d < e; d++)(f = a[d]) !== c && (b += c = f); return b }; var ja = { encode: ia, F: !1, G: "" }; function ia(a) { return ca.call(this, ("" + a).toLowerCase(), !1) }; const ka = {}, G = {}; function la(a) { I(a, "add"); I(a, "append"); I(a, "search"); I(a, "update"); I(a, "remove") } function I(a, b) { a[b + "Async"] = function () { const c = this, d = arguments; var e = d[d.length - 1]; let f; D(e) && (f = e, delete d[d.length - 1]); e = new Promise(function (g) { setTimeout(function () { c.async = !0; const h = c[b].apply(c, d); c.async = !1; g(h) }) }); return f ? (e.then(f), this) : e } }; function ma(a, b, c, d) {
                const e = a.length; let f = [], g, h, k = 0; d && (d = []); for (let m = e - 1; 0 <= m; m--) { const n = a[m], w = n.length, q = v(); let r = !g; for (let l = 0; l < w; l++) { const p = n[l], z = p.length; if (z) for (let B = 0, A, y; B < z; B++)if (y = p[B], g) { if (g[y]) { if (!m) if (c) c--; else if (f[k++] = y, k === b) return f; if (m || d) q[y] = 1; r = !0 } if (d && (A = (h[y] || 0) + 1, h[y] = A, A < e)) { const H = d[A - 2] || (d[A - 2] = []); H[H.length] = y } } else q[y] = 1 } if (d) g || (h = q); else if (!r) return []; g = q } if (d) for (let m = d.length - 1, n, w; 0 <= m; m--) {
                    n = d[m]; w = n.length; for (let q = 0, r; q < w; q++)if (r =
                        n[q], !g[r]) { if (c) c--; else if (f[k++] = r, k === b) return f; g[r] = 1 }
                } return f
            } function na(a, b) { const c = v(), d = v(), e = []; for (let f = 0; f < a.length; f++)c[a[f]] = 1; for (let f = 0, g; f < b.length; f++) { g = b[f]; for (let h = 0, k; h < g.length; h++)k = g[h], c[k] && !d[k] && (d[k] = 1, e[e.length] = k) } return e }; function J(a) { this.l = !0 !== a && a; this.cache = v(); this.h = [] } function oa(a, b, c) { C(a) && (a = a.query); let d = this.cache.get(a); d || (d = this.search(a, b, c), this.cache.set(a, d)); return d } J.prototype.set = function (a, b) { if (!this.cache[a]) { var c = this.h.length; c === this.l ? delete this.cache[this.h[c - 1]] : c++; for (--c; 0 < c; c--)this.h[c] = this.h[c - 1]; this.h[0] = a } this.cache[a] = b }; J.prototype.get = function (a) { const b = this.cache[a]; if (this.l && b && (a = this.h.indexOf(a))) { const c = this.h[a - 1]; this.h[a - 1] = this.h[a]; this.h[a] = c } return b }; const qa = { memory: { charset: "latin:extra", D: 3, B: 4, m: !1 }, performance: { D: 3, B: 3, s: !1, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, "default": {} }; function ra(a, b, c, d, e, f, g) { setTimeout(function () { const h = a(c ? c + "." + d : d, JSON.stringify(g)); h && h.then ? h.then(function () { b.export(a, b, c, e, f + 1) }) : b.export(a, b, c, e, f + 1) }) }; function K(a, b) {
                if (!(this instanceof K)) return new K(a); var c; if (a) { x(a) ? a = qa[a] : (c = a.preset) && (a = Object.assign({}, c[c], a)); c = a.charset; var d = a.lang; x(c) && (-1 === c.indexOf(":") && (c += ":default"), c = G[c]); x(d) && (d = ka[d]) } else a = {}; let e, f, g = a.context || {}; this.encode = a.encode || c && c.encode || ia; this.register = b || v(); this.D = e = a.resolution || 9; this.G = b = c && c.G || a.tokenize || "strict"; this.depth = "strict" === b && g.depth; this.l = u(g.bidirectional); this.s = f = u(a.optimize); this.m = u(a.fastupdate); this.B = a.minlength || 1; this.C =
                    a.boost; this.map = f ? aa(e) : v(); this.A = e = g.resolution || 1; this.h = f ? aa(e) : v(); this.F = c && c.F || a.rtl; this.H = (b = a.matcher || d && d.H) && fa(b, !1); this.J = (b = a.stemmer || d && d.J) && fa(b, !0); if (c = b = a.filter || d && d.filter) { c = b; d = v(); for (let h = 0, k = c.length; h < k; h++)d[c[h]] = 1; c = d } this.filter = c; this.cache = (b = a.cache) && new J(b)
            } t = K.prototype; t.append = function (a, b) { return this.add(a, b, !0) };
            t.add = function (a, b, c, d) {
                if (b && (a || 0 === a)) {
                    if (!d && !c && this.register[a]) return this.update(a, b); b = this.encode(b); if (d = b.length) {
                        const m = v(), n = v(), w = this.depth, q = this.D; for (let r = 0; r < d; r++) {
                            let l = b[this.F ? d - 1 - r : r]; var e = l.length; if (l && e >= this.B && (w || !n[l])) {
                                var f = L(q, d, r), g = ""; switch (this.G) {
                                    case "full": if (2 < e) { for (f = 0; f < e; f++)for (var h = e; h > f; h--)if (h - f >= this.B) { var k = L(q, d, r, e, f); g = l.substring(f, h); M(this, n, g, k, a, c) } break } case "reverse": if (1 < e) {
                                        for (h = e - 1; 0 < h; h--)g = l[h] + g, g.length >= this.B && M(this, n,
                                            g, L(q, d, r, e, h), a, c); g = ""
                                    } case "forward": if (1 < e) { for (h = 0; h < e; h++)g += l[h], g.length >= this.B && M(this, n, g, f, a, c); break } default: if (this.C && (f = Math.min(f / this.C(b, l, r) | 0, q - 1)), M(this, n, l, f, a, c), w && 1 < d && r < d - 1) for (e = v(), g = this.A, f = l, h = Math.min(w + 1, d - r), e[f] = 1, k = 1; k < h; k++)if ((l = b[this.F ? d - 1 - r - k : r + k]) && l.length >= this.B && !e[l]) { e[l] = 1; const p = this.l && l > f; M(this, m, p ? f : l, L(g + (d / 2 > g ? 0 : 1), d, r, h - 1, k - 1), a, c, p ? l : f) }
                                }
                            }
                        } this.m || (this.register[a] = 1)
                    }
                } return this
            };
            function L(a, b, c, d, e) { return c && 1 < a ? b + (d || 0) <= a ? c + (e || 0) : (a - 1) / (b + (d || 0)) * (c + (e || 0)) + 1 | 0 : 0 } function M(a, b, c, d, e, f, g) { let h = g ? a.h : a.map; if (!b[c] || g && !b[c][g]) a.s && (h = h[d]), g ? (b = b[c] || (b[c] = v()), b[g] = 1, h = h[g] || (h[g] = v())) : b[c] = 1, h = h[c] || (h[c] = []), a.s || (h = h[d] || (h[d] = [])), f && h.includes(e) || (h[h.length] = e, a.m && (a = a.register[e] || (a.register[e] = []), a[a.length] = h)) }
            t.search = function (a, b, c) {
                c || (!b && C(a) ? (c = a, a = c.query) : C(b) && (c = b)); let d = [], e; let f, g = 0; if (c) { a = c.query || a; b = c.limit; g = c.offset || 0; var h = c.context; f = c.suggest } if (a && (a = this.encode("" + a), e = a.length, 1 < e)) { c = v(); var k = []; for (let n = 0, w = 0, q; n < e; n++)if ((q = a[n]) && q.length >= this.B && !c[q]) if (this.s || f || this.map[q]) k[w++] = q, c[q] = 1; else return d; a = k; e = a.length } if (!e) return d; b || (b = 100); h = this.depth && 1 < e && !1 !== h; c = 0; let m; h ? (m = a[0], c = 1) : 1 < e && a.sort(ba); for (let n, w; c < e; c++) {
                    w = a[c]; h ? (n = sa(this, d, f, b, g, 2 === e, w,
                        m), f && !1 === n && d.length || (m = w)) : n = sa(this, d, f, b, g, 1 === e, w); if (n) return n; if (f && c === e - 1) { k = d.length; if (!k) { if (h) { h = 0; c = -1; continue } return d } if (1 === k) return ta(d[0], b, g) }
                } return ma(d, b, g, f)
            };
            function sa(a, b, c, d, e, f, g, h) { let k = [], m = h ? a.h : a.map; a.s || (m = ua(m, g, h, a.l)); if (m) { let n = 0; const w = Math.min(m.length, h ? a.A : a.D); for (let q = 0, r = 0, l, p; q < w; q++)if (l = m[q]) if (a.s && (l = ua(l, g, h, a.l)), e && l && f && (p = l.length, p <= e ? (e -= p, l = null) : (l = l.slice(e), e = 0)), l && (k[n++] = l, f && (r += l.length, r >= d))) break; if (n) { if (f) return ta(k, d, 0); b[b.length] = k; return } } return !c && k } function ta(a, b, c) { a = 1 === a.length ? a[0] : [].concat.apply([], a); return c || a.length > b ? a.slice(c, c + b) : a }
            function ua(a, b, c, d) { c ? (d = d && b > c, a = (a = a[d ? b : c]) && a[d ? c : b]) : a = a[b]; return a } t.contain = function (a) { return !!this.register[a] }; t.update = function (a, b) { return this.remove(a).add(a, b) };
            t.remove = function (a, b) { const c = this.register[a]; if (c) { if (this.m) for (let d = 0, e; d < c.length; d++)e = c[d], e.splice(e.indexOf(a), 1); else N(this.map, a, this.D, this.s), this.depth && N(this.h, a, this.A, this.s); b || delete this.register[a]; if (this.cache) { b = this.cache; for (let d = 0, e, f; d < b.h.length; d++)f = b.h[d], e = b.cache[f], e.includes(a) && (b.h.splice(d--, 1), delete b.cache[f]) } } return this };
            function N(a, b, c, d, e) { let f = 0; if (a.constructor === Array) if (e) b = a.indexOf(b), -1 !== b ? 1 < a.length && (a.splice(b, 1), f++) : f++; else { e = Math.min(a.length, c); for (let g = 0, h; g < e; g++)if (h = a[g]) f = N(h, b, c, d, e), d || f || delete a[g] } else for (let g in a) (f = N(a[g], b, c, d, e)) || delete a[g]; return f } t.searchCache = oa;
            t.export = function (a, b, c, d, e) { let f, g; switch (e || (e = 0)) { case 0: f = "reg"; if (this.m) { g = v(); for (let h in this.register) g[h] = 1 } else g = this.register; break; case 1: f = "cfg"; g = { doc: 0, opt: this.s ? 1 : 0 }; break; case 2: f = "map"; g = this.map; break; case 3: f = "ctx"; g = this.h; break; default: return }ra(a, b || this, c, f, d, e, g); return !0 }; t.import = function (a, b) { if (b) switch (x(b) && (b = JSON.parse(b)), a) { case "cfg": this.s = !!b.opt; break; case "reg": this.m = !1; this.register = b; break; case "map": this.map = b; break; case "ctx": this.h = b } }; la(K.prototype); function va(a) { a = a.data; var b = self._index; const c = a.args; var d = a.task; switch (d) { case "init": d = a.options || {}; a = a.factory; b = d.encode; d.cache = !1; b && 0 === b.indexOf("function") && (d.encode = Function("return " + b)()); a ? (Function("return " + a)()(self), self._index = new self.FlexSearch.Index(d), delete self.FlexSearch) : self._index = new K(d); break; default: a = a.id, b = b[d].apply(b, c), postMessage("search" === d ? { id: a, msg: b } : { id: a }) } }; let wa = 0; function O(a) { if (!(this instanceof O)) return new O(a); var b; a ? D(b = a.encode) && (a.encode = b.toString()) : a = {}; (b = (self || window)._factory) && (b = b.toString()); const c = "undefined" === typeof window && self.exports, d = this; this.o = xa(b, c, a.worker); this.h = v(); if (this.o) { if (c) this.o.on("message", function (e) { d.h[e.id](e.msg); delete d.h[e.id] }); else this.o.onmessage = function (e) { e = e.data; d.h[e.id](e.msg); delete d.h[e.id] }; this.o.postMessage({ task: "init", factory: b, options: a }) } } P("add"); P("append"); P("search");
            P("update"); P("remove"); function P(a) { O.prototype[a] = O.prototype[a + "Async"] = function () { const b = this, c = [].slice.call(arguments); var d = c[c.length - 1]; let e; D(d) && (e = d, c.splice(c.length - 1, 1)); d = new Promise(function (f) { setTimeout(function () { b.h[++wa] = f; b.o.postMessage({ task: a, id: wa, args: c }) }) }); return e ? (d.then(e), this) : d } }
            function xa(a, b, c) { let d; try { d = b ? eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")') : a ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + va.toString()], { type: "text/javascript" }))) : new Worker(x(c) ? c : "worker/worker.js", { type: "module" }) } catch (e) { } return d }; function Q(a) {
                if (!(this instanceof Q)) return new Q(a); var b = a.document || a.doc || a, c; this.K = []; this.h = []; this.A = []; this.register = v(); this.key = (c = b.key || b.id) && S(c, this.A) || "id"; this.m = u(a.fastupdate); this.C = (c = b.store) && !0 !== c && []; this.store = c && v(); this.I = (c = b.tag) && S(c, this.A); this.l = c && v(); this.cache = (c = a.cache) && new J(c); a.cache = !1; this.o = a.worker; this.async = !1; c = v(); let d = b.index || b.field || b; x(d) && (d = [d]); for (let e = 0, f, g; e < d.length; e++)f = d[e], x(f) || (g = f, f = f.field), g = C(g) ? Object.assign({}, a, g) : a,
                    this.o && (c[f] = new O(g), c[f].o || (this.o = !1)), this.o || (c[f] = new K(g, this.register)), this.K[e] = S(f, this.A), this.h[e] = f; if (this.C) for (a = b.store, x(a) && (a = [a]), b = 0; b < a.length; b++)this.C[b] = S(a[b], this.A); this.index = c
            } function S(a, b) { const c = a.split(":"); let d = 0; for (let e = 0; e < c.length; e++)a = c[e], 0 <= a.indexOf("[]") && (a = a.substring(0, a.length - 2)) && (b[d] = !0), a && (c[d++] = a); d < c.length && (c.length = d); return 1 < d ? c : c[0] } function T(a, b) { if (x(b)) a = a[b]; else for (let c = 0; a && c < b.length; c++)a = a[b[c]]; return a }
            function U(a, b, c, d, e) { a = a[e]; if (d === c.length - 1) b[e] = a; else if (a) if (a.constructor === Array) for (b = b[e] = Array(a.length), e = 0; e < a.length; e++)U(a, b, c, d, e); else b = b[e] || (b[e] = v()), e = c[++d], U(a, b, c, d, e) } function V(a, b, c, d, e, f, g, h) { if (a = a[g]) if (d === b.length - 1) { if (a.constructor === Array) { if (c[d]) { for (b = 0; b < a.length; b++)e.add(f, a[b], !0, !0); return } a = a.join(" ") } e.add(f, a, h, !0) } else if (a.constructor === Array) for (g = 0; g < a.length; g++)V(a, b, c, d, e, f, g, h); else g = b[++d], V(a, b, c, d, e, f, g, h) } t = Q.prototype;
            t.add = function (a, b, c) {
                C(a) && (b = a, a = T(b, this.key)); if (b && (a || 0 === a)) {
                    if (!c && this.register[a]) return this.update(a, b); for (let d = 0, e, f; d < this.h.length; d++)f = this.h[d], e = this.K[d], x(e) && (e = [e]), V(b, e, this.A, 0, this.index[f], a, e[0], c); if (this.I) { let d = T(b, this.I), e = v(); x(d) && (d = [d]); for (let f = 0, g, h; f < d.length; f++)if (g = d[f], !e[g] && (e[g] = 1, h = this.l[g] || (this.l[g] = []), !c || !h.includes(a))) if (h[h.length] = a, this.m) { const k = this.register[a] || (this.register[a] = []); k[k.length] = h } } if (this.store && (!c || !this.store[a])) {
                        let d;
                        if (this.C) { d = v(); for (let e = 0, f; e < this.C.length; e++)f = this.C[e], x(f) ? d[f] = b[f] : U(b, d, f, 0, f[0]) } this.store[a] = d || b
                    }
                } return this
            }; t.append = function (a, b) { return this.add(a, b, !0) }; t.update = function (a, b) { return this.remove(a).add(a, b) };
            t.remove = function (a) { C(a) && (a = T(a, this.key)); if (this.register[a]) { for (var b = 0; b < this.h.length && (this.index[this.h[b]].remove(a, !this.o), !this.m); b++); if (this.I && !this.m) for (let c in this.l) { b = this.l[c]; const d = b.indexOf(a); -1 !== d && (1 < b.length ? b.splice(d, 1) : delete this.l[c]) } this.store && delete this.store[a]; delete this.register[a] } return this };
            t.search = function (a, b, c, d) {
                c || (!b && C(a) ? (c = a, a = "") : C(b) && (c = b, b = 0)); let e = [], f = [], g, h, k, m, n, w, q = 0; if (c) if (c.constructor === Array) k = c, c = null; else { a = c.query || a; k = (g = c.pluck) || c.index || c.field; m = c.tag; h = this.store && c.enrich; n = "and" === c.bool; b = c.limit || b || 100; w = c.offset || 0; if (m && (x(m) && (m = [m]), !a)) { for (let l = 0, p; l < m.length; l++)if (p = ya.call(this, m[l], b, w, h)) e[e.length] = p, q++; return q ? e : [] } x(k) && (k = [k]) } k || (k = this.h); n = n && (1 < k.length || m && 1 < m.length); const r = !d && (this.o || this.async) && []; for (let l = 0, p, z, B; l <
                    k.length; l++) { let A; z = k[l]; x(z) || (A = z, z = A.field, a = A.query || a, b = A.limit || b); if (r) r[l] = this.index[z].searchAsync(a, b, A || c); else { d ? p = d[l] : p = this.index[z].search(a, b, A || c); B = p && p.length; if (m && B) { const y = []; let H = 0; n && (y[0] = [p]); for (let X = 0, pa, R; X < m.length; X++)if (pa = m[X], B = (R = this.l[pa]) && R.length) H++, y[y.length] = n ? [R] : R; H && (p = n ? ma(y, b || 100, w || 0) : na(p, y), B = p.length) } if (B) f[q] = z, e[q++] = p; else if (n) return [] } } if (r) {
                        const l = this; return new Promise(function (p) {
                            Promise.all(r).then(function (z) {
                                p(l.search(a, b,
                                    c, z))
                            })
                        })
                    } if (!q) return []; if (g && (!h || !this.store)) return e[0]; for (let l = 0, p; l < f.length; l++) { p = e[l]; p.length && h && (p = za.call(this, p)); if (g) return p; e[l] = { field: f[l], result: p } } return e
            }; function ya(a, b, c, d) { let e = this.l[a], f = e && e.length - c; if (f && 0 < f) { if (f > b || c) e = e.slice(c, c + b); d && (e = za.call(this, e)); return { tag: a, result: e } } } function za(a) { const b = Array(a.length); for (let c = 0, d; c < a.length; c++)d = a[c], b[c] = { id: d, doc: this.store[d] }; return b } t.contain = function (a) { return !!this.register[a] }; t.get = function (a) { return this.store[a] };
            t.set = function (a, b) { this.store[a] = b; return this }; t.searchCache = oa; t.export = function (a, b, c, d, e) { e || (e = 0); d || (d = 0); if (d < this.h.length) { const f = this.h[d], g = this.index[f]; b = this; setTimeout(function () { g.export(a, b, e ? f : "", d, e++) || (d++, e = 1, b.export(a, b, f, d, e)) }) } else { let f, g; switch (e) { case 1: f = "tag"; g = this.l; break; case 2: f = "store"; g = this.store; break; default: return }ra(a, this, c, f, d, e, g) } };
            t.import = function (a, b) { if (b) switch (x(b) && (b = JSON.parse(b)), a) { case "tag": this.l = b; break; case "reg": this.m = !1; this.register = b; for (let d = 0, e; d < this.h.length; d++)e = this.index[this.h[d]], e.register = b, e.m = !1; break; case "store": this.store = b; break; default: a = a.split("."); const c = a[0]; a = a[1]; c && a && this.index[c].import(a, b) } }; la(Q.prototype); var Ba = { encode: Aa, F: !1, G: "" }; const Ca = [F("[\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5]"), "a", F("[\u00e8\u00e9\u00ea\u00eb]"), "e", F("[\u00ec\u00ed\u00ee\u00ef]"), "i", F("[\u00f2\u00f3\u00f4\u00f5\u00f6\u0151]"), "o", F("[\u00f9\u00fa\u00fb\u00fc\u0171]"), "u", F("[\u00fd\u0177\u00ff]"), "y", F("\u00f1"), "n", F("[\u00e7c]"), "k", F("\u00df"), "s", F(" & "), " and "]; function Aa(a) { var b = a = "" + a; b.normalize && (b = b.normalize("NFD").replace(ea, "")); return ca.call(this, b.toLowerCase(), !a.normalize && Ca) }; var Ea = { encode: Da, F: !1, G: "strict" }; const Fa = /[^a-z0-9]+/, Ga = { b: "p", v: "f", w: "f", z: "s", x: "s", "\u00df": "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" }; function Da(a) { a = Aa.call(this, a).join(" "); const b = []; if (a) { const c = a.split(Fa), d = c.length; for (let e = 0, f, g = 0; e < d; e++)if ((a = c[e]) && (!this.filter || !this.filter[a])) { f = a[0]; let h = Ga[f] || f, k = h; for (let m = 1; m < a.length; m++) { f = a[m]; const n = Ga[f] || f; n && n !== k && (h += n, k = n) } b[g++] = h } } return b }; var Ia = { encode: Ha, F: !1, G: "" }; const Ja = [F("ae"), "a", F("oe"), "o", F("sh"), "s", F("th"), "t", F("ph"), "f", F("pf"), "f", F("(?![aeo])h(?![aeo])"), "", F("(?!^[aeo])h(?!^[aeo])"), ""]; function Ha(a, b) { a && (a = Da.call(this, a).join(" "), 2 < a.length && (a = E(a, Ja)), b || (1 < a.length && (a = ha(a)), a && (a = a.split(" ")))); return a || [] }; var La = { encode: Ka, F: !1, G: "" }; const Ma = F("(?!\\b)[aeo]"); function Ka(a) { a && (a = Ha.call(this, a, !0), 1 < a.length && (a = a.replace(Ma, "")), 1 < a.length && (a = ha(a)), a && (a = a.split(" "))); return a || [] }; G["latin:default"] = ja; G["latin:simple"] = Ba; G["latin:balance"] = Ea; G["latin:advanced"] = Ia; G["latin:extra"] = La; const W = self; let Y; const Z = { Index: K, Document: Q, Worker: O, registerCharset: function (a, b) { G[a] = b }, registerLanguage: function (a, b) { ka[a] = b } }; (Y = W.define) && Y.amd ? Y([], function () { return Z }) : W.exports ? W.exports = Z : W.FlexSearch = Z;
        }(this));

    </script>

    <script src="https://cdn.jsdelivr.net/npm/mark.js"></script>


    <style>
        /* CSS for highlighted text */
        mark {
            background-color: yellow;
            color: black;
            font-weight: bold;
        }
    </style>
    <link href="https://cdn.jsdelivr.net/npm/prismjs@v1.x/themes/prism.css" rel="stylesheet" />
    <style>
        code {
            white-space: pre-wrap !important;
        }

        /* html, body{
            max-width: 980px;
        } */
        /* Add custom styles for the drawer button */
        #drawerButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .grayed-out-button {
            color: #ccc;
            /* Set the text color to gray */
            background-color: #f4f4f4;
            /* Set a light gray background color */
            border: 1px solid #ccc;
            /* Add a gray border */
            cursor: not-allowed;
            /* Change the cursor to indicate the button is disabled */
            pointer-events: none;
            /* Disable pointer events to prevent interaction */
        }

        .grayed-out-button i {
            color: #ccc;
            /* Set the icon color to gray */
        }


        #drawer {
            /* to visualize the alignment of buttons and text */
            background-color: white;
            margin: auto;
            /* margin: 1.5%; */
            /* margin-right: 10%; */
            text-wrap: wrap;
            /* margin-bottom: 10px; */
        }

        #drawer_mask {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            /* background-color: rgba(0, 0, 0, 0.1); */
        }

        #progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #progress-bar {
            height: 20px;
            background-color: #f2f2f2;
            border: 1px solid #ccc;
            overflow: hidden;
        }

        #progress-bar .progress {
            width: 0;
            height: 100%;
            background-color: #4caf50 !important;
        }
    </style>
    <style>
        /* html, body{
        background-color: transparent;
    }
    input {
        background-color: transparent;
    } */

        .search-container {
            margin-bottom: 10px;
        }

        /* 
        h3,
        h4 {
            line-height: 0.5;
        } */

        p {
            line-height: 1.5;
        }

        h2 {
            overflow-x: auto;
        }

        /* Styles for mobile devices */
        @media (max-width: 767px) {

            #progress-bar {

                width: 60%;
            }

            /*(h2{
            font-size: 27px;
        }*/
            html,
            body {

                margin-left: 3%;
                margin-right: 3%;
            }

            .repository-url {
                display: none;
            }

            .search-container {
                border: 1px solid #ccc;
            }

            .right-half {
                /*padding-left: 10px;*/
                padding-right: 10px;
                overflow-y: auto;
                overflow-x: auto;
            }

            .left-half {
                padding-left: 15px;
                padding-right: 10px;

                padding-top: 5px;
                padding-bottom: 5px;
            }

            #searchResults,
            #searchInput {
                font-size: 14px;
            }

            #searchInput {
                z-index: 10;
                text-indent: 15px;
            }

            .searchItemInfo {
                padding-left: 15px;
            }
        }

        /* Styles for desktop devices */
        @media (min-width: 768px) {

            #progress-bar {
                width: 50%;
            }

            #searchInput {
                z-index: 10;
                text-indent: 20px;
            }

            html,
            body {

                margin-left: 5%;
                margin-right: 5%;
            }

            #searchResults,
            #searchInput {
                font-size: 17px;
            }

            .searchItemInfo {
                padding-left: 20px;
            }

            .search-container {
                display: flex;
                border: 1px solid #ccc;
                /* justify-content: space-between; */
                /* flex-direction: row; */
                height: min-content;
                /* align-items: flex-start; */
            }

            .left-half {
                flex: 1;
                /* align-self: stretch; */
                height: 100%;
                overflow-x: auto;

                /* overflow-y: auto; */
            }

            .right-half {
                flex: 1;
                /* height:100%; */

                /* align-self: stretch; */
                overflow-x: auto;
                overflow-y: scroll;
            }

            .right-half {

                padding-right: 20px;
            }

            .left-half {
                padding-top: 5px;
                padding-left: 20px;
                padding-right: 20px;
            }
        }

        .left-half {
            background-color: #ccc;

        }

        .right-half {
            background-color: #f1f1f1;
        }

        .highlight {
            background-color: yellow !important;
            color: black !important;
        }

        .monospace-text {
            font-family: "Courier New", monospace;
            color: #333;
        }

        /* useless now */
        pre {
            overflow-x: visible !important;
            overflow-y: visible !important;
            /* overflow-x: auto; */
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
        }

        button {
            cursor: pointer;
        }

        .codelink:hover {
            cursor: pointer;
            text-decoration: underline;
        }

        .codelink {
            word-wrap: break-word;
            /* Allow long words to be broken and wrap onto the next line */
            overflow-wrap: break-word
        }

        /*
    .searchItemInfo:hover {
         cursor: pointer;
    }
    .search-container:hover {
         cursor: pointer;
    }
    */
        .searchItem {
            padding: 10px;
            padding-bottom: 0;
            padding-top: 0;
            border: 1px solid #ccc;
        }

        /*
    .searchItemInfo {
        padding: 10px;
    }
*/
    </style>
    <style type="text/css">
        html,
        body {
            /*max-width: 900px;*/
            /* font-family: 'Roboto', sans-serif; */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            height: 100%;
            /* margin: 0; */
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: left;
            justify-content: center;
            text-align: left;
            /* margin: 5%; */
            margin-bottom: 10px;
            margin-top: 1.5%;
        }

        input[type="text"] {
            padding: 10px;
            /*border-radius: 10px;*/
            border: 1px solid #ccc;
        }

        .input-group {
            position: relative;
            display: flex;
            /* flex-wrap: wrap; */
            /* align-items: stretch; */
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }

        .input-group-button:hover {
            cursor: pointer;
        }

        #sidebar-button:hover {
            cursor: pointer;
        }

        .input-group-button {
            border: 1px solid #ccc;
            /* padding:auto; */
            /* flex:1; */
            z-index: 9;
            padding: 10px;
            margin: auto;
        }

        ul.search-results {
            flex: 1;
            /* Fill the remaining space */
            overflow-y: scroll;
            /* Enable vertical scrolling */
            list-style: none;
            padding: 0;
            /* margin: 5%; */
            margin-top: 0;
        }

        ul.search-results li {
            background-color: #f2f2f2;
            margin-bottom: 10px;
            /*border-radius: 10px;*/
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        }

        #drawer_content>div>span:hover {
            cursor: pointer;
            text-decoration: underline;
        }
    </style>

</head>


<body>
    <!-- <div> -->
    <div id="drawer_mask" style="display:none;"></div>
    <div id="drawer" style="display:none;">
        <h2><span id="drawer_title"></span></h2>
        <div id="drawer_content" style="line-height: 1.8; overflow-y:scroll; height:75%">
            <!-- <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world world world world world world world world world world world world world world</div> -->
            <!-- subterms shall also be bold, but font size is smaller. -->
            <!-- <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div>
           <div><b>Basic Python Output: "world"</b></div>
           <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForDOMContentLoaded</div> -->

        </div>
    </div>
    <!-- <div style="max-width: 980px; margin:0 auto;"> -->
    <div id="progress-overlay">
        <div id="progress-bar">
            <div class="progress"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@v1.x/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
    <header class="container">
        <h2 style="display: flex; justify-content: space-between; align-items: center;">
            <div id="document_index"
                style="flex: 1; float: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                Document index<span class="repository-url"> of:
                    <span id="partial-repository-url"></span></span></div>
            <div style="float: right;">
                <a title="Github repository" id="github-link" class="github-icon"><i class="fab fa-github"></i></a>
                <a title="Project structure" id="brief-link" href="tree.html"><i class="bi bi-text-right"></i></a>
                <a title="Result overview" href="#" id="sidebar-open" style="position:relative; z-index:8888;"><i
                        class="bi bi-caret-left-square"></i></a>
            </div>
        </h2>
        <div class="input-group">
            <input type="text" id="searchInput" style="flex:1;" placeholder="Search...">
            <button type="button" id="file_previous" class="input-group-button" title="Previous file"
                style="display:none;"><i class="bi bi-caret-left"></i></button> <button type="button" id="file_next"
                class="input-group-button" title="Next file" style="display:none;"><i
                    class="bi bi-caret-right"></i></button>
        </div>
    </header>
    <ul class="search-results" id="searchResults"></ul>
    <script type="text/javascript" defer>
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (Math.random() * 16) | 0,
                    v = c == 'x' ? r : (r & 0x3) | 0x8;
                return v.toString(16);
            });
        }
        function toggleDrawer() {
            const drawer = document.getElementById('drawer');
            const mybutton = document.getElementById('sidebar-open');
            const drawer_mask = document.getElementById('drawer_mask');
            const drawer_title = document.getElementById('drawer_title');
            const drawer_content = document.getElementById('drawer_content');
            if (drawer.style.display != 'none') {
                drawer.style.display = "none";
                drawer_mask.style.display = "none";
                mybutton.innerHTML = `<i class="bi bi-caret-left-square"></i>`;
                mybutton.setAttribute("title", "Result overview")
                return;
            } else {
                mybutton.innerHTML = `<i class="bi bi-caret-right-square"></i>`;
                mybutton.setAttribute("title", "Hide overview")

            }

            // var element_close = document.getElementById("sidebar-close")
            // var element = document.getElementById("sidebar-open");

            // Get the position of the element
            // var rect = element.getBoundingClientRect();

            // Get the top and left position
            // element_close.style.position = 'absolute';
            // element_close.style.top = rect.top+"px";
            // element_close.style.left = rect.left+"px";


            drawer.style.position = 'absolute';
            var pageHeight = window.innerHeight;
            var pageWidth = window.innerWidth;
            drawer.style.height = pageHeight + 'px';
            drawer.style.width = pageWidth / 2 + 'px';

            drawer.style.top = '0px';
            if (pageWidth > 768) {
                drawer.style.left = `${pageWidth / 2}px`;
                drawer.style.width = "50%"
                drawer.style.borderLeft = "1px solid #ccc";


            } else {
                drawer.style.left = `0px`;
                drawer.style.width = "100%"
            }
            drawer.style.height = "100%"
            // drawer.style.backgroundColor = "#ccc !important";
            drawer.style.zIndex = '999';
            drawer.style.display = '';

            drawer_mask.style.zIndex = '998';
            drawer_mask.style.display = "";
            // Get the reference element
            var referenceElement = document.getElementById("document_index");

            // Get the top and left position of the reference element
            var rect = referenceElement.getBoundingClientRect();
            var topPosition = rect.top;
            var leftPosition = rect.left;

            // Position the target element at the same top and left coordinates as the reference element
            drawer_title.style.position = "absolute";
            drawer_title.style.top = topPosition * 1 + "px";
            // drawer_title.style.top = topPosition*1.5 + "px";
            if (pageWidth > 768) {
                drawer_title.style.left = pageWidth * 0.02 + "px";
                // drawer_title.style.left = pageWidth * 0.03 + "px";

            } else {
                drawer_title.style.left = leftPosition + "px";

            }

            // var paddingRightSize = topPosition;
            // drawer.style.marginRight = paddingRightSize*8 + "px";

            var referenceElement = document.getElementById("searchInput");

            // Get the top and left position of the reference element
            var rect = referenceElement.getBoundingClientRect();
            var topPosition = rect.top;
            var leftPosition = rect.left;

            drawer_content.style.position = "absolute";
            drawer_content.style.top = topPosition + "px";
            if (pageWidth > 768) {
                drawer_content.style.left = pageWidth * 0.04 + "px";
                drawer_content.style.width = "75%"
                drawer_content.style.fontSize = "large";
                // drawer_title.style.left = pageWidth * 0.03 + "px";
            } else {
                drawer_content.style.width = "83%"
                drawer_content.style.left = leftPosition * 2 + "px";
                drawer_content.style.fontSize = "medium";

            }

            drawer_title.textContent = "Overview";
        }


        function jumpToElement(elementId) {
            var element = document.getElementById(elementId);
            if (element) {
                element.scrollIntoView({ behavior: "smooth", block: "start" });
            }
        }
        function toggleDrawerAndJumpToElement(elementId) {
            toggleDrawer();
            jumpToElement(elementId);
        }
        // TODO: paging
        const RESULT_LIMIT = 15;
        // const RESULT_LIMIT = 50;
        const progressOverlay = document.getElementById('progress-overlay');
        const progressBar = document.querySelector('.progress');
        var isDebugMode = false;
        function navigateToPage(base_filepath, language_id, project_id, keywords, detail_filepath = "") {
            // Use a relative path to navigate to a specific page
            let page_param = "codeview.html";
            let file_param = 'src' + base_filepath;
            file_param = encodeURIComponent(file_param);
            let language_param = language_id
            let keywords_encoded = encodeURIComponent(JSON.stringify(keywords));
            let jump_link = `${page_param}?file=${file_param}&language=${language_id}&project=${project_id}&keywords=${keywords_encoded}`;
            if (detail_filepath !== "") {
                let location_range = detail_filepath.slice(base_filepath.length + 1);
                let location_param = `mycode.${location_range}`;
                jump_link = `${jump_link}#${location_param}`;
            }
            window.location.href = jump_link;
        }
        /*async function waitForDOMContentLoaded() {
            return new Promise(resolve => {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', resolve);
                } else {
                    resolve();
                }
            });
        }
        */


        document.getElementById("sidebar-open").onclick = toggleDrawer;
        // document.getElementById("sidebar-close").onclick = toggleDrawer;

        // Sample data for demonstration
        // async function async_main() {
        function async_main() {

            //const metadata_req = await fetch("metadata.json")// load from server
            //const metadata = JSON.parse(await metadata_req.text())
            var xhr = new XMLHttpRequest();
            xhr.open('GET', "metadata.json", false); // The third parameter is set to false for synchronous request
            xhr.send(null);
            const metadata = JSON.parse(xhr.responseText);

            const github_url = metadata.url.full;
            const project_id = metadata.project_name;
            const myDefaultTitle = `Document index of: ${project_id}`
            document.title = myDefaultTitle;
            const github_partial_url = metadata.url.partial;
            const file_mapping = metadata.file_mapping
            const split_count = metadata.split_count

            var xhr = new XMLHttpRequest();
            xhr.open('GET', "metadata_title.json", false); // The third parameter is set to false for synchronous request
            xhr.send(null);
            const metadata_title = JSON.parse(xhr.responseText);

            const title_split_count = metadata_title.split_count;
            const total_split_count = split_count + title_split_count;

            var data_var = {}
            for (let i = 0; i < split_count; i++) {
                //let data_req = await fetch(`data/${i}.json`)// load from server
                //let data_part = JSON.parse(await data_req.text())

                var xhr = new XMLHttpRequest();
                xhr.open('GET', `data/${i}.json`, false); // The third parameter is set to false for synchronous request
                xhr.send(null);
                let data_part = JSON.parse(xhr.responseText);

                //data_var = { ...data_part, ...data_var }
                data_var = Object.assign(data_var, data_part)
                const progressPercentage = ((i + 1) / total_split_count) * 100;
                progressBar.style.width = `${progressPercentage}%`;
            }
            var title_data_var = {}
            for (let i = 0; i < title_split_count; i++) {

                var xhr = new XMLHttpRequest();
                xhr.open('GET', `data/titles/${i}.json`, false); // The third parameter is set to false for synchronous request
                xhr.send(null);
                let data_part = JSON.parse(xhr.responseText);

                //data_var = { ...data_part, ...data_var }
                title_data_var = Object.assign(title_data_var, data_part)
                const progressPercentage = ((split_count + i + 1) / total_split_count) * 100;
                progressBar.style.width = `${progressPercentage}%`;
            }
            progressOverlay.style.display = 'none';


            const data = data_var // obviously not constant.
            const title_data = title_data_var

            // console.log(title_data);
            // debugger;

            const data_total_length = Object.keys(data).length;
            // debugger
            var sourceCodePaths_v = [];
            var sourceCodeIndexRanges_v = {};
            const file_total_count = Object.keys(file_mapping).length;
            for (let i = 0; i < file_total_count; i++) {
                sourceCodePaths_v.push(file_mapping[i].filepath)
                const entry_left = file_mapping[i].entry_id
                var entry_right;
                if ((i + 1) > (file_total_count - 1)) {
                    entry_right = data_total_length
                }
                else {
                    // console.log(i, i + 1, file_total_count)
                    entry_right = file_mapping[i + 1].entry_id
                }
                if (entry_right == entry_left) {
                    console.log(i, i + 1, file_total_count, entry_left, entry_right);
                    debugger
                }
                sourceCodeIndexRanges_v[file_mapping[i].filepath] = {
                    left: entry_left,
                    right: entry_right
                }
            }
            sourceCodePaths_v.sort(function (a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            const sourceCodePaths = sourceCodePaths_v;
            const sourceCodePathCount = sourceCodePaths.length;
            const sourceCodeIndexRanges = sourceCodeIndexRanges_v;

            // Create a new FlexSearch instance with the required configuration
            const doc = new FlexSearch.Document({
                tokenize: "full",
                document: {
                    id: "id",
                    index: ["content"]
                }
            });

            // Add the data to the search index
            Object.keys(data).forEach(id => {
                doc.add(id, data[id]);
            });
            const englishSymbols = ["!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"];

            function replaceAll(inputString, searchValue, replaceValue) {
                return inputString.split(searchValue).join(replaceValue);
            }
            function getSubTerms(it) {
                it = it.trim();
                var ret = [it]
                for (const sym of englishSymbols) {
                    var m_str = it
                    m_str = replaceAll(m_str, sym, " ");
                    ret.concat(m_str.split(" "))
                }
                ret = ret.concat(it.split(" "))
                ret = ret.concat(m_str.split(" "));
                return ret
            }

            const searchInputElem = document.getElementById('searchInput');
            var isSearchRunning = false;
            var hasInputEvent = false;
            var lastInputEventTime = new Date().getTime();
            function searchInputEventListener() {

                function capitalizeFirstLetter(text) {
                    return text.charAt(0).toUpperCase() + text.slice(1);
                }
                function mutateText(text) {
                    var lowerText = text.toLowerCase()
                    var upperText = text.toUpperCase()
                    var lowerCapitalized = capitalizeFirstLetter(lowerText)
                    return [text, lowerText, upperText, lowerCapitalized]
                }

                const searchTerm = searchInputElem.value.trim();


                const file_previous = document.getElementById("file_previous");
                const file_next = document.getElementById("file_next");
                // Display the search results
                const searchResults = document.getElementById('searchResults');
                searchResults.innerHTML = '';
                const drawer_content = document.getElementById('drawer_content');
                drawer_content.innerHTML = "";
                // file_next.classList.add("grayed-out-button")
                // file_previous.classList.add("grayed-out-button")
                file_next.style.display = "none"
                file_previous.style.display = "none"
                if (searchTerm.length == 0) { return }

                const searchSubTerms = getSubTerms(searchTerm);
                function getHighlightTerms(msubterms) {
                    var ret = []
                    for (var it of msubterms) {
                        if (it.length > 0) {
                            for (var mut of mutateText(it)) {
                                if (ret.indexOf(mut) == -1) {
                                    ret.push(mut);
                                }
                            }
                        }
                    }
                    return ret;
                }

                var isFileSearch = false;

                if (searchTerm.startsWith("/")) {
                    const searchTermFileIndex = sourceCodePaths.indexOf(searchTerm)
                    // console.log('search term file index:', searchTermFileIndex)
                    if (searchTermFileIndex != -1) {
                        isFileSearch = true;
                        document.title = `File: ${searchTerm} - ${myDefaultTitle}`
                        // do something with the buttons
                        // file_previous file_next
                        if (searchTermFileIndex != 0) {
                            // console.log('showing file previous button')
                            file_previous.style.display = "";
                            // file_previous.classList.remove("grayed-out-button")
                            file_previous.onclick = () => { window.location.href = `?q=${encodeURIComponent(sourceCodePaths[searchTermFileIndex - 1])}` };
                        }
                        if (searchTermFileIndex != (sourceCodePathCount - 1)) {
                            // console.log('showing file next button')
                            // file_next.classList.remove("grayed-out-button")
                            file_next.style.display = "";
                            file_next.onclick = () => { window.location.href = `?q=${encodeURIComponent(sourceCodePaths[searchTermFileIndex + 1])}` };
                        }

                    }
                }
                var searchHighlightTerms;
                var results;

                if (isFileSearch) {
                    searchHighlightTerms = [];
                    const queryFileRange = sourceCodeIndexRanges[searchTerm];
                    var results_v = [];
                    var ids = []
                    for (var i = queryFileRange.left; i < queryFileRange.right; i++) {
                        ids.push(i);
                    }
                    var it = { field: 'content', result: ids }
                    results_v.push(it)
                    results = results_v;
                } else {
                    searchHighlightTerms = getHighlightTerms(searchSubTerms);
                    results = doc.search(searchTerm, RESULT_LIMIT); // Limiting to 5 results for demonstration
                }
                // console.log(isFileSearch,results);

                const detail_types = ["code", "comment"];

                var searchResultItems = {};
                var searchResultItemIds = [];
                var leftElements = [];
                var rightElements = [];

                results.forEach(result => {
                    const field = result.field; // "content"
                    const ids = result.result;
                    ids.forEach(id => {
                        id = id - 0 // to integer.
                        const data_type = data[id].type;
                        const file_id = data[id].file_id;
                        if (searchResultItems[file_id] === undefined) {
                            searchResultItemIds.push(file_id);
                            const file_metadata = file_mapping[file_id];
                            const entry_id = file_metadata.entry_id;
                            const summary = data[entry_id + 1].content;
                            const filepath = file_metadata.filepath;
                            const language_id = file_metadata.language_id;
                            searchResultItems[file_id] = { "header": { "summary": summary, "filepath": filepath }, "pairs": {}, "language_id": language_id };
                        }
                        if (detail_types.indexOf(data_type) != -1) {
                            const pair_id = ((data_type === "code") ? id : (id - 1));
                            if (searchResultItems[file_id].pairs[pair_id] === undefined) {
                                // console.log(pair_id, pair_id+1, data_type, data[pair_id].location)
                                let mit = { "left": data[pair_id].content, "right": data[pair_id + 1].content, "location": data[pair_id].location, "hit": [data_type] }
                                // let mit = { "left": data[pair_id].content, "right": data[pair_id - 1].content, "location": data[pair_id].location }
                                // console.log(mit)
                                searchResultItems[file_id].pairs[pair_id] = mit;
                            }
                            else {
                                searchResultItems[file_id].pairs[pair_id].hit.push(data_type)
                            }
                        }
                        // listItem.textContent = `[${field}][${data_type}] ${data[id][field]}`;
                        // searchResults.appendChild(listItem);
                    });
                });
                var isDesktopScreen = window.innerWidth > 768;
                var isFirstDrawerEntry = true;
                var title_topics = []
                for (var file_id of searchResultItemIds) {
                    const it = searchResultItems[file_id];
                    const item = document.createElement('li');
                    //const item = document.createElement('div');
                    item.className = "searchItem";
                    const search_header = document.createElement('div');
                    search_header.className = "searchItemInfo";
                    const file_title_elem = document.createElement('h3');
                    const overview_file_title_elem = document.createElement('div');
                    const file_title_elem_id = generateUUID()
                    file_title_elem.setAttribute('id', file_title_elem_id)
                    const mylocation = it.header.filepath.slice(1)
                    title_topics.push(title_data["/" + mylocation])

                    overview_file_title_elem.innerHTML = `&bull;&nbsp;<span>${title_data["/" + mylocation]}</span>`;
                    if (isFirstDrawerEntry) {
                        isFirstDrawerEntry = false;
                    }else{
                        overview_file_title_elem.style.marginTop = '7px'
                    }
                    overview_file_title_elem.onclick = () => {
                        //  jumpToElement(file_title_elem_id); 
                        toggleDrawerAndJumpToElement(file_title_elem_id);
                    };
                    drawer_content.appendChild(overview_file_title_elem);
                    const location_p = document.createElement('p');
                    // location_p.className = "monospace-text";
                    location_p.className = "monospace-text codelink";
                    // file_title_elem.className = "codelink";
                    const file_title_span = document.createElement("span")
                    file_title_span.textContent = title_data["/" + mylocation]
                    file_title_span.setAttribute("title", mylocation)
                    file_title_elem.appendChild(file_title_span);
                    location_p.innerHTML = (mylocation);

                    if (isFileSearch) {
                        location_p.onclick = () => { navigateToPage(it.header.filepath, it.language_id, project_id, searchHighlightTerms) }
                    } else {
                        location_p.onclick = () => { window.location.href = "?q=/" + encodeURIComponent(mylocation) }
                    }
                    // if (isFileSearch) {
                    //     file_title_span.onclick = () => { navigateToPage(it.header.filepath, it.language_id, project_id, searchHighlightTerms) }
                    // } else {
                    //     file_title_span.onclick = () => { window.location.href = "?q=/" + encodeURIComponent(mylocation) }
                    // }

                    // file_title_span.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)},${JSON.stringify(project_id)})`)
                    // location_p.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)}, ${JSON.stringify(project_id)})`)
                    search_header.appendChild(location_p);
                    search_header.appendChild(file_title_elem);

                    var skip_summary = false;

                    if (Object.keys(it.pairs).length == 1) {
                        if (it.pairs[Object.keys(it.pairs)[0]].right == it.header.summary) {
                            skip_summary = true;
                        }
                    }
                    if (!skip_summary) {
                        const summary_p = document.createElement('p');
                        summary_p.innerHTML = (it.header.summary);
                        search_header.appendChild(summary_p);
                    }
                    //search_header.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)})`)


                    item.appendChild(search_header);


                    for (var pair_id in it.pairs) {
                        const pair_container = document.createElement('div');
                        pair_container.className = "search-container";
                        const pair = it.pairs[pair_id];
                        const pair_item = document.createElement('div');
                        const pair_left = document.createElement('div');
                        const pair_title = document.createElement('h4');
                        const pair_title_id = generateUUID();
                        pair_title.setAttribute('id', pair_title_id);
                        const pair_location_text = pair.location.slice(1);
                        const pair_title_text = title_data["/" + pair_location_text];
                        const code_title_span = document.createElement('span')
                        const overview_pair_title = document.createElement('div');
                        if (isDesktopScreen) {
                            overview_pair_title.style.fontSize = "medium";
                        } else {
                            overview_pair_title.style.fontSize = "small";
                        }
                        overview_pair_title.onclick = () => {
                            // jumpToElement(pair_title_id);
                            toggleDrawerAndJumpToElement(pair_title_id);
                        }
                        if (pair_title_text != undefined) {
                            code_title_span.textContent = pair_title_text
                            overview_pair_title.innerHTML = `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>${pair_title_text}</span>`
                            // overview_pair_title.innerHTML = `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#9702;&nbsp;<span>${pair_title_text}</span>`
                        }
                        pair_title.appendChild(code_title_span);
                        pair_left.className = "left-half";
                        const code_location_p = document.createElement('p');
                        // pair_title.className = "codelink";
                        // code_location_p.className = "monospace-text";
                        code_location_p.className = "monospace-text codelink";
                        code_location_p.innerHTML = (pair_location_text);
                        code_title_span.setAttribute("title", pair_location_text)
                        // code_title_span.onclick = () => { navigateToPage(it.header.filepath, it.language_id, project_id, searchHighlightTerms, pair.location) }
                        // code_title_span.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)},  ${JSON.stringify(project_id)}, ${JSON.stringify(pair.location)})`)
                        code_location_p.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)},  ${JSON.stringify(project_id)}, ${JSON.stringify(pair.location)})`)
                        pair_left.appendChild(code_location_p);
                        if (pair_title_text != undefined) {
                            pair_left.appendChild(pair_title);
                            drawer_content.appendChild(overview_pair_title);
                        }
                        // const comment_p = document.createElement('pre');
                        const comment_p = document.createElement('p');
                        comment_p.setAttribute('style', 'white-space: pre-line;');
                        comment_p.innerHTML = (pair.right);
                        pair_left.appendChild(comment_p);

                        const pair_right = document.createElement('div');
                        pair_right.className = "right-half";
                        const code_pre = document.createElement('pre');
                        const code_code = document.createElement('code');
                        code_code.className = `language-${it.language_id}`
                        // Set the "data-dependencies" attribute
                        // code_code.setAttribute('data-dependencies', it.language_id+"!");
                        code_code.textContent = pair.left;
                        code_pre.appendChild(code_code);
                        //code_pre.className = "monospace-text";
                        //code_pre.innerHTML = highlightTerm(pair.left);
                        pair_right.appendChild(code_pre);

                        leftElements.push(pair_left);
                        rightElements.push(pair_right);
                        pair_container.appendChild(pair_left); // comment
                        pair_container.appendChild(pair_right);
                        // if (pair.hit.indexOf("code") != -1) {
                        // }// code
                        //pair_container.setAttribute('onclick', `navigateToPage(${JSON.stringify(it.header.filepath)}, ${JSON.stringify(it.language_id)}, ${JSON.stringify(pair.location)})`)
                        item.appendChild(pair_container);
                    }
                    //li_elem = document.createElement('li');
                    //li_elem.appendChild(item);
                    //searchResults.appendChild(li_elem);

                    searchResults.appendChild(item);
                }

                Prism.highlightAllUnder(searchResults);
                const title_topics_joined = title_topics.join(" | ")
                document.title = `${document.title} - Topics: ${title_topics_joined}`
                // let's try understand that.
                const markInstance = new Mark(document.getElementById('searchResults'));
                markInstance.unmark(); // Clear previous marks
                markInstance.mark(searchHighlightTerms);
                for (let i in leftElements) {
                    let leftHeight = leftElements[i].clientHeight;
                    let rightHeight = rightElements[i].clientHeight;
                    if (leftHeight < rightHeight) {
                        rightElements[i].style.height = leftHeight + "px";
                    }
                }
            }


            function getQueryParams() {
                var search = window.location.search.substring(1); // Remove leading '?'
                var queryParams = {};
                search.split('&').forEach(function (pair) {
                    var parts = pair.split('=');
                    var key = decodeURIComponent(parts[0]);
                    var value = decodeURIComponent(parts[1]);
                    queryParams[key] = value;
                });
                return queryParams;
            }
            // Event listener for the search input
            function registerSearchEventListener() {
                // this is never called
                document.getElementById("partial-repository-url").innerText = github_partial_url;
                document.getElementById("github-link").setAttribute("href", github_url);
                // get query parameters.
                // function keyPressListener(event) {
                //     if (event.key === 'Enter') {
                //         searchInputEventListener();
                //     }
                // }
                // searchInputElem.addEventListener('keypress',
                //     // searchInputElem.addEventListener('input',
                //     // searchInputEventListener
                //     keyPressListener
                // );
                setInterval(() => {
                    if (hasInputEvent) {
                        let currentTime = new Date().getTime();
                        if ((currentTime - lastInputEventTime) > 500) // .5 sec
                        {
                            const inputBoxText = document.getElementById('searchInput').value;
                            inputBoxText.trim()
                            var newURL;
                            if (inputBoxText.trim() !== "") {
                                // Construct the new URL with the updated query string
                                newURL = `${window.location.protocol}//${window.location.host}${window.location.pathname}?q=${inputBoxText}`;
                                document.title = `Query: ${inputBoxText.trim()} - ${myDefaultTitle}`;
                            }
                            else {
                                newURL = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
                                document.title = myDefaultTitle;

                            }

                            // Use history.pushState() to update the URL without reloading the page
                            history.pushState(null, null, newURL);

                            hasInputEvent = false;
                            if (!isSearchRunning) {
                                isSearchRunning = true;
                                try {
                                    searchInputEventListener();
                                } catch (error) {
                                    // Print exception info
                                    console.error(error);
                                    if (isDebugMode) {
                                        // Show alert window in debug mode
                                        console.log(error.message);
                                        alert("An error occurred when searching: " + error.message);
                                    } else {
                                        // Raise exception when not in debug mode
                                        throw error;
                                    }
                                }
                                isSearchRunning = false;
                            }
                        }
                    }
                }, 100)

                searchInputElem.addEventListener('input', () => {
                    hasInputEvent = true;
                    lastInputEventTime = new Date().getTime();
                })


                function setTextAndTriggerInputEvent(queryString) {
                    searchInputElem.value = queryString; // Set text into the input box
                    // searchInputElem.dispatchEvent(new Event('keypress')); // Fire an input event
                    // var enterKeyEvent = new KeyboardEvent('keypress', {
                    //     key: 'Enter'
                    // });
                    // searchInputElem.dispatchEvent(enterKeyEvent);
                    hasInputEvent = true;
                }
                function displayFile(file_path) {
                    // TODO: handle file query string
                }

                //const queryParams = new URLSearchParams(window.location.search);
                const queryParams = getQueryParams(window.location.search);
                const query_from_url = queryParams.q;
                const file_path_from_url = queryParams.file;
                isDebugMode = queryParams.debug == 'true';
                if (isDebugMode) { console.log("You are in debug mode.") }
                if (query_from_url != null || query_from_url != undefined) {
                    setTextAndTriggerInputEvent(query_from_url)
                } else if (file_path_from_url != null || file_path_from_url != undefined) {
                    displayFile(file_path_from_url)
                }
            }

            //document.addEventListener('DOMContentLoaded', registerSearchEventListener);
            // waitForDOMContentLoaded();
            registerSearchEventListener()
            // console.log("event listener registered")
        }
        async_main()
    </script>
    <!-- </div> -->
</body>


</html>